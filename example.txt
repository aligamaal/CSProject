#include <crow.h>
#include <crow/json.h>
#include <string>
#include <vector>
#include <map>
#include <random>
#include <sstream>
#include <iomanip>
#include <openssl/sha.h>
#include <ctime>
#include <iostream>

// User class to store user information
class User {
private:
    int user_id;
    std::string username;
    std::string email;
    std::string password_hash;
    std::string salt;
    std::time_t created_at;

public:
    User(int id, const std::string& uname, const std::string& user_email, 
         const std::string& password, const std::string& user_salt)
        : user_id(id), username(uname), email(user_email), 
          password_hash(password), salt(user_salt), created_at(std::time(nullptr)) {}

    // Getters
    int getUserId() const { return user_id; }
    std::string getUsername() const { return username; }
    std::string getEmail() const { return email; }
    std::string getPasswordHash() const { return password_hash; }
    std::string getSalt() const { return salt; }
    std::time_t getCreatedAt() const { return created_at; }

    // Verify password
    bool verifyPassword(const std::string& password, const std::string& hash_function_result) const {
        return password_hash == hash_function_result;
    }
};

// Session class to manage user sessions
class Session {
private:
    std::string session_id;
    int user_id;
    std::time_t created_at;
    std::time_t expires_at;

public:
    Session(const std::string& id, int uid) 
        : session_id(id), user_id(uid), created_at(std::time(nullptr)) {
        expires_at = created_at + (24 * 60 * 60); // 24 hours from creation
    }

    std::string getSessionId() const { return session_id; }
    int getUserId() const { return user_id; }
    bool isValid() const { return std::time(nullptr) < expires_at; }
};

// Authentication Service class
class AuthService {
private:
    static std::vector<User> users;
    static std::map<std::string, Session> active_sessions;
    static int next_user_id;

    // Generate random salt
    static std::string generateSalt() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 255);
        
        std::stringstream ss;
        for (int i = 0; i < 16; ++i) {
            ss << std::hex << dis(gen);
        }
        return ss.str();
    }

    // Hash password with salt using SHA-256
    static std::string hashPassword(const std::string& password, const std::string& salt) {
        std::string salted_password = password + salt;
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256_CTX sha256;
        SHA256_Init(&sha256);
        SHA256_Update(&sha256, salted_password.c_str(), salted_password.length());
        SHA256_Final(hash, &sha256);
        
        std::stringstream ss;
        for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
        }
        return ss.str();
    }

    // Generate session token
    static std::string generateSessionToken() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 61);
        
        std::string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        std::string token;
        for (int i = 0; i < 32; ++i) {
            token += chars[dis(gen)];
        }
        return token;
    }

public:
    // Register new user
    static std::pair<bool, std::string> registerUser(const std::string& username, 
                                                    const std::string& email, 
                                                    const std::string& password) {
        // Check if username already exists
        for (const auto& user : users) {
            if (user.getUsername() == username) {
                return {false, "Username already exists"};
            }
            if (user.getEmail() == email) {
                return {false, "Email already registered"};
            }
        }

        // Validate input
        if (username.empty() || email.empty() || password.empty()) {
            return {false, "All fields are required"};
        }

        if (password.length() < 6) {
            return {false, "Password must be at least 6 characters"};
        }

        // Create new user
        std::string salt = generateSalt();
        std::string password_hash = hashPassword(password, salt);
        
        User new_user(next_user_id++, username, email, password_hash, salt);
        users.push_back(new_user);

        return {true, "User registered successfully"};
    }

    // Login user
    static std::pair<bool, std::string> loginUser(const std::string& username, 
                                                 const std::string& password) {
        // Find user
        User* user = nullptr;
        for (auto& u : users) {
            if (u.getUsername() == username) {
                user = &u;
                break;
            }
        }

        if (!user) {
            return {false, "Invalid username or password"};
        }

        // Verify password
        std::string password_hash = hashPassword(password, user->getSalt());
        if (!user->verifyPassword(password, password_hash)) {
            return {false, "Invalid username or password"};
        }

        // Create session
        std::string session_token = generateSessionToken();
        Session new_session(session_token, user->getUserId());
        active_sessions[session_token] = new_session;

        return {true, session_token};
    }

    // Validate session
    static std::pair<bool, int> validateSession(const std::string& session_token) {
        auto it = active_sessions.find(session_token);
        if (it == active_sessions.end()) {
            return {false, -1};
        }

        if (!it->second.isValid()) {
            active_sessions.erase(it);
            return {false, -1};
        }

        return {true, it->second.getUserId()};
    }

    // Logout user
    static bool logoutUser(const std::string& session_token) {
        auto it = active_sessions.find(session_token);
        if (it != active_sessions.end()) {
            active_sessions.erase(it);
            return true;
        }
        return false;
    }

    // Get user by ID
    static User* getUserById(int user_id) {
        for (auto& user : users) {
            if (user.getUserId() == user_id) {
                return &user;
            }
        }
        return nullptr;
    }

    // Get all users (for debugging)
    static std::vector<User> getAllUsers() {
        return users;
    }

    // Clear expired sessions
    static void clearExpiredSessions() {
        auto it = active_sessions.begin();
        while (it != active_sessions.end()) {
            if (!it->second.isValid()) {
                it = active_sessions.erase(it);
            } else {
                ++it;
            }
        }
    }
};

// Static member definitions
std::vector<User> AuthService::users;
std::map<std::string, Session> AuthService::active_sessions;
int AuthService::next_user_id = 1;

// Helper function to extract session token from request
std::string extractSessionToken(const crow::request& req) {
    auto auth_header = req.get_header_value("Authorization");
    if (auth_header.empty()) {
        return "";
    }
    
    // Expected format: "Bearer <token>"
    if (auth_header.substr(0, 7) == "Bearer ") {
        return auth_header.substr(7);
    }
    
    return "";
}

int main() {
    crow::SimpleApp app;

    // Enable CORS for frontend integration
    app.use(crow::cors());

    // Root endpoint
    CROW_ROUTE(app, "/")([]() {
        return "Social Media Backend API - Authentication System\n"
               "Available endpoints:\n"
               "POST /api/auth/register - Register new user\n"
               "POST /api/auth/login - User login\n"
               "POST /api/auth/logout - User logout\n"
               "GET /api/auth/session - Validate session\n"
               "GET /api/user/profile - Get user profile\n";
    });

    // User registration endpoint
    CROW_ROUTE(app, "/api/auth/register").methods("POST"_method)
    ([](const crow::request& req) {
        try {
            auto json_data = crow::json::load(req.body);
            if (!json_data) {
                return crow::response(400, "{\"error\": \"Invalid JSON\"}");
            }

            std::string username = json_data["username"].s();
            std::string email = json_data["email"].s();
            std::string password = json_data["password"].s();

            auto result = AuthService::registerUser(username, email, password);
            
            if (result.first) {
                crow::json::wvalue response;
                response["success"] = true;
                response["message"] = result.second;
                return crow::response(201, response);
            } else {
                crow::json::wvalue response;
                response["success"] = false;
                response["error"] = result.second;
                return crow::response(400, response);
            }
        } catch (const std::exception& e) {
            crow::json::wvalue response;
            response["success"] = false;
            response["error"] = "Server error";
            return crow::response(500, response);
        }
    });

    // User login endpoint
    CROW_ROUTE(app, "/api/auth/login").methods("POST"_method)
    ([](const crow::request& req) {
        try {
            auto json_data = crow::json::load(req.body);
            if (!json_data) {
                return crow::response(400, "{\"error\": \"Invalid JSON\"}");
            }

            std::string username = json_data["username"].s();
            std::string password = json_data["password"].s();

            auto result = AuthService::loginUser(username, password);
            
            if (result.first) {
                crow::json::wvalue response;
                response["success"] = true;
                response["session_token"] = result.second;
                response["message"] = "Login successful";
                return crow::response(200, response);
            } else {
                crow::json::wvalue response;
                response["success"] = false;
                response["error"] = result.second;
                return crow::response(401, response);
            }
        } catch (const std::exception& e) {
            crow::json::wvalue response;
            response["success"] = false;
            response["error"] = "Server error";
            return crow::response(500, response);
        }
    });

    // Session validation endpoint
    CROW_ROUTE(app, "/api/auth/session").methods("GET"_method)
    ([](const crow::request& req) {
        std::string session_token = extractSessionToken(req);
        
        if (session_token.empty()) {
            crow::json::wvalue response;
            response["success"] = false;
            response["error"] = "No session token provided";
            return crow::response(401, response);
        }

        auto result = AuthService::validateSession(session_token);
        
        if (result.first) {
            User* user = AuthService::getUserById(result.second);
            if (user) {
                crow::json::wvalue response;
                response["success"] = true;
                response["user_id"] = user->getUserId();
                response["username"] = user->getUsername();
                response["email"] = user->getEmail();
                return crow::response(200, response);
            }
        }
        
        crow::json::wvalue response;
        response["success"] = false;
        response["error"] = "Invalid or expired session";
        return crow::response(401, response);
    });

    // User logout endpoint
    CROW_ROUTE(app, "/api/auth/logout").methods("POST"_method)
    ([](const crow::request& req) {
        std::string session_token = extractSessionToken(req);
        
        if (session_token.empty()) {
            crow::json::wvalue response;
            response["success"] = false;
            response["error"] = "No session token provided";
            return crow::response(401, response);
        }

        bool success = AuthService::logoutUser(session_token);
        
        crow::json::wvalue response;
        response["success"] = success;
        response["message"] = success ? "Logout successful" : "Invalid session";
        return crow::response(success ? 200 : 401, response);
    });

    // Get user profile endpoint
    CROW_ROUTE(app, "/api/user/profile").methods("GET"_method)
    ([](const crow::request& req) {
        std::string session_token = extractSessionToken(req);
        
        if (session_token.empty()) {
            crow::json::wvalue response;
            response["success"] = false;
            response["error"] = "No session token provided";
            return crow::response(401, response);
        }

        auto result = AuthService::validateSession(session_token);
        
        if (result.first) {
            User* user = AuthService::getUserById(result.second);
            if (user) {
                crow::json::wvalue response;
                response["success"] = true;
                response["user"] = crow::json::wvalue{
                    {"user_id", user->getUserId()},
                    {"username", user->getUsername()},
                    {"email", user->getEmail()},
                    {"created_at", static_cast<int64_t>(user->getCreatedAt())}
                };
                return crow::response(200, response);
            }
        }
        
        crow::json::wvalue response;
        response["success"] = false;
        response["error"] = "Invalid or expired session";
        return crow::response(401, response);
    });

    // Debug endpoint to list all users (remove in production)
    CROW_ROUTE(app, "/api/debug/users").methods("GET"_method)
    ([]() {
        crow::json::wvalue response;
        response["users"] = crow::json::wvalue::list();
        
        auto users = AuthService::getAllUsers();
        for (size_t i = 0; i < users.size(); ++i) {
            response["users"][i] = crow::json::wvalue{
                {"user_id", users[i].getUserId()},
                {"username", users[i].getUsername()},
                {"email", users[i].getEmail()}
            };
        }
        
        return crow::response(200, response);
    });

    // Set up periodic cleanup of expired sessions
    std::cout << "Starting Social Media Backend Server..." << std::endl;
    std::cout << "Server running on http://localhost:8080" << std::endl;
    std::cout << "Available endpoints:" << std::endl;
    std::cout << "  POST /api/auth/register" << std::endl;
    std::cout << "  POST /api/auth/login" << std::endl;
    std::cout << "  POST /api/auth/logout" << std::endl;
    std::cout << "  GET  /api/auth/session" << std::endl;
    std::cout << "  GET  /api/user/profile" << std::endl;

    app.port(8080).multithreaded().run();
    return 0;
}
